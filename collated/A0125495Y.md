# A0125495Y
###### Test\RunAllTests.java
``` java

import org.junit.runner.RunWith;
import org.junit.extensions.cpsuite.ClasspathSuite;

@RunWith(ClasspathSuite.class)

public class RunAllTests {

}
```
###### Test\Time4WorkStorage\FilterTaskTest.java
``` java

public class FilterTaskTest {
	
	public ArrayList<Tasks> myList = new ArrayList<Tasks>();
	public Tasks tempTask1, tempTask2, tempTask3, tempTask4 = null;
	public FilterTask myFilter = new FilterTask();
	
	@Before
	public void setUp() {
		
		myList = new ArrayList<Tasks>();
		tempTask1 = null;
		tempTask2 = null;
		tempTask3 = null;
		tempTask4 = null;
		
		Duration tempDeadLine = new Duration("290915", "1800" , "300915", "2000");
		tempTask1 = new DurationTask("I'm a duration task", tempDeadLine );
		myList.add(tempTask1);
		
		tempDeadLine = new Duration("300915", "1200");
		tempTask2 = new DeadlineTask("I'm a deadLine task", tempDeadLine );
		myList.add(tempTask2);
		
		tempTask3 = new FloatingTask("I'm a flooooating task");
		myList.add(tempTask3);
	}
	
	@Test
	public void testSearchDescription() {
		
		//checking exact word matches
		assertEquals(myFilter.searchDescription(myList, "DURATION").size(), 1);
		assertTrue(myFilter.searchDescription(myList, "DURATION").get(0).equals(tempTask1));
		assertEquals(myFilter.searchDescription(myList, "exist").size(), 0);
		assertEquals(myFilter.searchDescription(myList, "task DOESN'T").size(), 3);
		assertEquals(myFilter.searchDescription(myList, "nonexistent DOESN'T").size(), 0);
		
		//added 1 more with same word 
		myList.add(tempTask1);
		assertEquals(myFilter.searchDescription(myList, "DURATION").size(), 2);
		
		//checks starting with
		assertEquals(myFilter.searchDescription(myList, "i").size(), 4);
		tempTask4 = new FloatingTask("This doesn't start with 'I' but contains 'I'");
		myList.add(tempTask4);		
		assertEquals(myFilter.searchDescription(myList, "i").size(), 4);		
		assertEquals(myFilter.searchDescription(myList, "i t").size(), 5);
		
		//checks single match within string but not starting with
		assertEquals(myFilter.searchDescription(myList, "a").size(), 4);	
		
		//checks near matches
		assertEquals(myFilter.searchDescription(myList, "dedline").size(), 1);
		assertEquals(myFilter.searchDescription(myList, "druation").size(), 2);
		assertEquals(myFilter.searchDescription(myList, "floooo").size(), 1);
		assertEquals(myFilter.searchDescription(myList, "Tsk").size(), 4);
	}
	
	@Test
	public void testSearchCompleted() {
		
		assertEquals(myFilter.searchCompleted(myList).size(), 0);
		assertEquals(myFilter.searchNotCompleted(myList).size(), 3);
		
		myList.get(1).setCompleted(true);
		
		assertEquals(myFilter.searchCompleted(myList).size(), 1);
		assertEquals(myFilter.searchNotCompleted(myList).size(), 2);
	}
	
	
	@Test
	public void testSearchType() {
		
		assertEquals(myFilter.searchFloating(myList).size(), 1);
		assertEquals(myFilter.searchDeadline(myList).size(), 1);		
		assertEquals(myFilter.searchDuration(myList).size(), 1);
	}
	
	@Test
	public void testSearchDate() {
		String dateMatch = "290915";
		String dateNotMatch = "300920";
		assertEquals(myFilter.searchDate(myList, dateMatch).size(), 1);
		assertEquals(myFilter.searchDate(myList, dateNotMatch).size(), 0);
	}
	
	@Test
	public void testSearchBeforeDate() {
		String dateMatch = "290915";
		String date2Match = "300915";
		String dateAllMatch = "290920";
		String dateNoMatch = "300914";
		try {
			assertEquals(myFilter.searchBeforeDate(myList, dateMatch).size(), 1);
			assertEquals(myFilter.searchBeforeDate(myList, date2Match).size(), 2);
			assertEquals(myFilter.searchBeforeDate(myList, dateAllMatch).size(), 2);
			assertEquals(myFilter.searchBeforeDate(myList, dateNoMatch).size(), 0);
		} catch (ParseException e) {
			e.printStackTrace();
		}
	}
	
	@Test
	public void testSearchOverdue() {
		
		Calendar cal = Calendar.getInstance();
		DateFormat format = new SimpleDateFormat("ddMMyy", Locale.ENGLISH);	
		
		cal.set(Calendar.DATE, 1);
		Date tomorrow = cal.getTime();
		String nextDay = format.format(tomorrow);
		
		Duration tempDeadLine = new Duration(nextDay, "2000");		
		tempTask4 = new DeadlineTask("This doesn't fail until tomorrow", tempDeadLine);
		myList.add(tempTask4);		
		
		try {
			assertEquals(myFilter.searchOverDue(myList).size(), 2);
		} catch (ParseException e) {
			e.printStackTrace();
		}
		
		cal.set(Calendar.DATE, -1);
		Date yesterday = cal.getTime();
		String previousDay = format.format(yesterday);
		
		tempDeadLine = new Duration(previousDay, "2000");
		tempTask4 = new DeadlineTask("This is overdue since yesterday", tempDeadLine);
		myList.add(tempTask4);
		
		try {
			assertEquals(myFilter.searchOverDue(myList).size(), 3);
		} catch (ParseException e) {
			e.printStackTrace();
		}
	}
	
	@Test
	public void testSearchBetweenDates() {
		
		try {
			assertEquals(myFilter.searchBetweenDates(myList, "290915", "290915").size(), 1);
			assertEquals(myFilter.searchBetweenDates(myList, "290915", "021115").size(), 2);
			assertEquals(myFilter.searchBetweenDates(myList, "010101", "020202").size(), 0);
		} catch (ParseException e) {
			e.printStackTrace();
		}
	}

}
```
###### Test\Time4WorkStorage\StorageLogicTest.java
``` java

public class StorageLogicTest {
	
	StorageLogic myLogic = new StorageLogic();
	Gson gson = new GsonBuilder().setPrettyPrinting().create();
	
	final String testFile = "testFile.txt";
	final Tasks tempTask1 = new FloatingTask(1, "I'm a floating task!");
	final String tempTask1String = gson.toJson(tempTask1);
	final Duration tempDeadLine2 = new Duration("300915", "1800" , "300915", "2000");
	final Tasks tempTask2 = new DurationTask(2, "I'm a duration task!", tempDeadLine2 );
	final String tempTask2String = gson.toJson(tempTask2);
	final Duration tempDeadLine3 = new Duration("310915", "1200");
	final Tasks tempTask3 = new DeadlineTask(3, "I'm a deadLine task!", tempDeadLine3 );
	final String tempTask3String = gson.toJson(tempTask3);
	
	File myFile;
	FileReader fr; 
	BufferedReader br;
	ArrayList<Tasks> tempList = new ArrayList<Tasks>();
	boolean fault;
	
	@Before
	public void setUp() {
		
		myFile = null;
		fault = false;
		
		try {
			myLogic.createCustomFile(testFile, false);
		} catch (IOException e1) {
			e1.printStackTrace();
			fault = true;
		}
		
		try {
			myLogic.addNewTask(tempTask1);
			myLogic.addNewTask(tempTask2);
			myLogic.addNewTask(tempTask3);
		} catch (IOException e) {
			e.printStackTrace();
			fault = true;
		}
	}
	
	//adds a new task and compares size
	@Test
	public void testAddNewTask() {

		if(!fault) {
			
			try {
				tempList = myLogic.getAllTasks();
			} catch (IOException e) {
				e.printStackTrace();
			}
			
			Duration tempDeadLine = new Duration("051115", "2000");
			Tasks tempTask4 = new DeadlineTask("New task", tempDeadLine);
			
			try {
				myLogic.addNewTask(tempTask4);
				tempList = myLogic.getAllTasks();
			} catch (IOException e) {
				e.printStackTrace();
			}
			
			assertEquals(tempList.size(),4);
		}
	}
	
	//deletes last item and compares size
	@Test
	public void testDeleteLast() {
		
		ArrayList<Integer> list3 = new ArrayList<Integer>();
		list3.add(3);		

		if(!fault) {
			
			try {
				tempList = myLogic.getAllTasks();
			} catch (IOException e) {
				e.printStackTrace();
			}
			
			assertEquals(tempList.size(),3);
			
			try {
				myLogic.delete(list3);
				tempList = myLogic.getAllTasks();
			} catch (IOException e) {
				e.printStackTrace();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}

			assertEquals(tempList.size(),2);

		}

	}
	
	//sets all 3 as completed
	@Test
	public void testSetCompleted() {
		
		ArrayList<Integer> list = new ArrayList<Integer>();
		list.add(1);
		list.add(2);
		list.add(3);
		
		if(!fault) {	
			try {
				myLogic.setCompleted(list, true);
			} catch (IOException | InterruptedException e) {
				e.printStackTrace();
				fault = true;
			}
		}
		
		if(!fault) {				
			try {
				tempList = myLogic.getAllTasks();
			} catch (IOException e) {
				e.printStackTrace();
				fault = true;
			}
			
			for(int i=0; i<tempList.size(); i++) {
				assertEquals(tempList.get(i).isCompleted(),true);
			}			

		}
	}
	
	//clears file contents
	@Test
	public void testClear() {
		
		if(!fault) {
			try {
				tempList = myLogic.getAllTasks();
			} catch (IOException e) {
					e.printStackTrace();
					fault = true;
			}
			
			assertTrue(tempList.size() != 0);
			
			try {
				myLogic.clear();
				tempList = myLogic.getAllTasks();
			} catch (IOException | InterruptedException e) {
				e.printStackTrace();
				fault = true;
			}			
	
			assertEquals(tempList.size(),0);
		}
	}
	
	
	@After
	public void cleanUp() throws InterruptedException {
		try {
			myLogic.deleteDataFile();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}	
}
```
###### Time4WorkStorage\CustomPathLogic.java
``` java

public class CustomPathLogic {
	
	private final String defPath = "pathcustom.txt";
	private File pathFile =  new File(defPath);
	private FileWriter fw;
	private FileReader fr; 
	private BufferedWriter bw;
	private BufferedReader br;
	
	private static final String MSG_WRITEROPEN_FAILED = "Unable to create writer for file";
	private static final String MSG_READEROPEN_FAILED = "Unable to create reader for file";
	private static final String MSG_WRITERCLOSE_FAILED = "Unable to close writer";
	private static final String MSG_READERCLOSE_FAILED = "Unable to close reader";
	private static final String MSG_FILEDELETION_FAILED = "Unable to delete file";
	private static final String BACKSLASH = "\\";
	

	
	//returns if custompath file exists
	public boolean savedPathExists() {
		return (pathFile.exists() && pathFile.isFile());
	}
	
	//writes the new path into file
	public void writeCustomPath(String customPath) throws IOException {
		
		customPath = customPath.replace(BACKSLASH, BACKSLASH+BACKSLASH);
		
		try {
			openWriter();
		} catch (IOException e) {
			throw e;
		}
		
		try {
			bw.write(customPath);
			bw.newLine();
		} catch (IOException e) {
			throw e;
		}
		
		try {
			closeWriter();
		} catch (IOException e) {
			throw e;
		}
	}
	
	//returns empty string if doesnt exist or file is empty
	public String readCustomPath() throws IOException {
		
		String savedPath = "";
		
		if(savedPathExists()) {
			try {
				openReader();
			} catch (IOException e) {
				throw e;
			}
			
			try {
				savedPath = br.readLine();
			} catch (IOException e) {
				throw e;
			}
			
			try {
				closeReader();
			} catch (IOException e) {
				throw e;
			}
		} 
		return savedPath;		
	}
	
	//delete path file
	public void deleteCustomPathFile() throws IOException {
		
		try {
			closeReader();
			closeWriter();
			fr.close();
			br.close();
		} catch (IOException e) {
			throw e;
		}
		
		System.gc();
		
		try {
			Thread.sleep(200);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		
		if (!pathFile.delete()) {
			throw new IOException(MSG_FILEDELETION_FAILED);
	    } 
	}
	
	private void openWriter() throws IOException, FileNotFoundException{

		try {
			fw = new FileWriter(pathFile.getAbsoluteFile());
			bw = new BufferedWriter(fw);
		} catch (IOException e) {
			throw new IOException(MSG_WRITEROPEN_FAILED);
		}
	}
	
	private void openReader() throws IOException, FileNotFoundException{

		try {
			fr = new FileReader(pathFile.getAbsoluteFile());
			br = new BufferedReader(fr);
		} catch (FileNotFoundException e) {
			throw new FileNotFoundException(MSG_READEROPEN_FAILED);
		}
	}	

	private void closeWriter() throws IOException {

			try {
				bw.close();
			} catch (IOException e) {
				throw new IOException(MSG_WRITERCLOSE_FAILED);
			}
	}
	
	private void closeReader() throws IOException {

		try {
			br.close();
		} catch (IOException e) {
			throw new IOException(MSG_READERCLOSE_FAILED);
		}
	}

}
```
###### Time4WorkStorage\DeadlineTask.java
``` java

public class DeadlineTask extends Tasks{
	
	private Duration durationDetails = null;
	private static final int DeadlineType = TaskType.DeadlineType.getTaskType();
	
	public DeadlineTask(int taskID, String desc, Duration duration) {
		super.setTaskID(taskID);
		super.setDescription(desc);
		super.setType(DeadlineType);
		setDurationDetails(duration);
	}
	
	public DeadlineTask(String desc, Duration duration) {
		super.setDescription(desc);
		super.setType(DeadlineType);
		setDurationDetails(duration);
	}
	
	public String getTime() {
		return durationDetails.getEndTime();
	}
	
	public void setTime(String eTime) {
		this.durationDetails.setEndTime(eTime);
	}
	
	public String getDate() {
		return durationDetails.getEndDate();
	}
	
	public void setDate(String eDate) {
		this.durationDetails.setEndDate(eDate);
	}

	public Duration getDurationDetails() {
		return durationDetails;
	}

	public void setDurationDetails(Duration durationDetails) {
		this.durationDetails = durationDetails;
	}
	
	
}
```
###### Time4WorkStorage\Duration.java
``` java

public class Duration {
	
	private String startDate = "";		//date format is “DDMMYY”
	private String startTime = "";		//time is 24hrs “0000”
	private String endDate = "";
	private String endTime = "";
	private int type = 0;				
	private static final int DeadlineType = TaskType.DeadlineType.getTaskType();
	private static final int DurationType = TaskType.DurationType.getTaskType();

	public Duration(String sDate, String sTime, String eDate, String eTime) {
		setStartDate(sDate);
		setStartTime(sTime);
		setEndDate(eDate);
		setEndTime(eTime);
		setType(DurationType);
	}
	
	public Duration(String eDate, String eTime) {
		setEndDate(eDate);
		setEndTime(eTime);
		setType(DeadlineType);
	}
	
	public String getStartDate() {
		return startDate;
	}

	public void setStartDate(String startDate) {
		this.startDate = startDate;
	}

	public String getStartTime() {
		return startTime;
	}

	public void setStartTime(String startTime) {
		this.startTime = startTime;
	}

	public String getEndDate() {
		return endDate;
	}

	public void setEndDate(String endDate) {
		this.endDate = endDate;
	}

	public String getEndTime() {
		return endTime;
	}

	public void setEndTime(String endTime) {
		this.endTime = endTime;
	}

	public int getType() {
		return type;
	}

	public void setType(int type) {
		this.type = type;
	}
}
```
###### Time4WorkStorage\DurationTask.java
``` java

public class DurationTask extends Tasks{
	
	private Duration durationDetails = null;	
	private static final int DurationType = TaskType.DurationType.getTaskType();
	
	public DurationTask(int taskID, String desc, Duration duration) {
		super.setTaskID(taskID);
		super.setDescription(desc);
		super.setType(DurationType);
		setDurationDetails(duration);
	}
	
	public DurationTask(String desc, Duration duration) {
		super.setDescription(desc);
		super.setType(DurationType);
		setDurationDetails(duration);
	}

	public Duration getDurationDetails() {
		return durationDetails;
	}

	public void setDurationDetails(Duration durationDetails) {
		this.durationDetails = durationDetails;
	}
	
	public String getStartTime() {
		return durationDetails.getStartTime();
	}
	
	public void setStartTime(String sTime) {
		this.durationDetails.setStartTime(sTime);
	}
	
	public String getStartDate() {
		return durationDetails.getStartDate();
	}
	
	public void setStartDate(String sDate) {
		this.durationDetails.setStartDate(sDate);
	}

	
	public String getEndTime() {
		return durationDetails.getEndTime();
	}
	
	public void setEndTime(String eTime) {
		this.durationDetails.setEndTime(eTime);
	}
	
	public String getEndDate() {
		return durationDetails.getEndDate();
	}
	
	public void setEndDate(String eDate) {
		this.durationDetails.setEndDate(eDate);
	}

	
	
}
```
###### Time4WorkStorage\FilterTask.java
``` java

import Time4WorkStorage.Tasks.TaskType;

public class FilterTask {
	
	private final int NEARMATCH_MAX = 3;
	private final String SPLITTER = "\\s";
	private static final int DeadlineType = TaskType.DeadlineType.getTaskType();
	private static final int DurationType = TaskType.DurationType.getTaskType();
	private static final int FloatingType = TaskType.FloatingType.getTaskType();
			
	//filters task description for matching task
	//single character will search for task with description starting with the character or matching single character description
	//multiple words will match all containing each word or near matches
	public ArrayList<Tasks> searchDescription(ArrayList<Tasks> myList, String searchString) {
		
		Levenshtein myLevenshtein = new Levenshtein();
		ArrayList<Tasks> resultList = new ArrayList<Tasks>();
		
		if(searchString == null) {
			return myList;
		}
		
		String[] splitString = searchString.split(SPLITTER);
		ArrayList<String> startWith = new ArrayList<String>();
		ArrayList<String> words = new ArrayList<String>();
		
		for(int i=0; i<splitString.length; i++) {
			if(splitString[i].length() == 1) {
				startWith.add(splitString[i]);
			}
			else {
				words.add(splitString[i]);
			}
		}
		
		for(int i=0; i<myList.size(); i++) {
			
			boolean added = false;
			for(int j=0; j<startWith.size(); j++) {
				//check starting with for single character searching
				if(myList.get(i).getDescription().substring(0,1).toUpperCase().equals(startWith.get(j).toUpperCase())) {
					added = true;
					break;
				}
			}
			
			if(!added) {
				for(int j=0; j<words.size(); j++) {
					//checks exact word matches
					if(myList.get(i).getDescription().toUpperCase().contains(words.get(j).toUpperCase())) {
						added = true;
						break;
					} 
				}
			}
			
			String[] brokenDesc = myList.get(i).getDescription().split(SPLITTER);
			
			if(!added) {	
				outerloop:
				for(int j=0; j<brokenDesc.length; j++) {					
					for(int m=0; m<startWith.size(); m++) {
						//checks single character matches with single description
						if(brokenDesc[j].equalsIgnoreCase(startWith.get(m))) {
							added = true;
							break outerloop;
						}									
					}
				}
			}
			
			if(!added) {
				outerloop:
				for(int j=0; j<brokenDesc.length; j++) {	
					for(int k=0; k<words.size(); k++) {
						//checks near matches
						int nearMatchLimit = words.get(k).length()/2;
						if(nearMatchLimit > NEARMATCH_MAX) {
							nearMatchLimit = NEARMATCH_MAX;
						}
						int isCloseMatch = myLevenshtein.distance(brokenDesc[j].toUpperCase(), words.get(k).toUpperCase(), nearMatchLimit);
						if(isCloseMatch != -1) {
							added = true;
							break outerloop;
						} 
					}
				}
			}
			if(added) {
				resultList.add(myList.get(i));
			}			
		}		
		return resultList;
	}
	
	
	private ArrayList<Tasks> searchCompletion(ArrayList<Tasks> myList, boolean completed) {
				
		ArrayList<Tasks> resultList = new ArrayList<Tasks>();
		
		for(int i=0; i<myList.size(); i++) {
			if(myList.get(i).isCompleted() == completed) {
				resultList.add(myList.get(i));
			}
		}		
		return resultList;
	}
	
	public ArrayList<Tasks> searchCompleted(ArrayList<Tasks> myList) {
		return searchCompletion(myList, true);
	}
	
	public ArrayList<Tasks> searchNotCompleted(ArrayList<Tasks> myList) {
		return searchCompletion(myList, false);
	}
	
	public ArrayList<Tasks> searchFloating(ArrayList<Tasks> myList) {
		return searchType(myList, FloatingType);
	}
	
	public ArrayList<Tasks> searchDeadline(ArrayList<Tasks> myList) {
		return searchType(myList, DeadlineType);
	}
	
	public ArrayList<Tasks> searchDuration(ArrayList<Tasks> myList) {
		return searchType(myList, DurationType);
	}
	

	public ArrayList<Tasks> searchDate(ArrayList<Tasks> myList, String date) {
		
		ArrayList<Tasks> resultList = new ArrayList<Tasks>();
		
		for(int i=0; i<myList.size(); i++) {
			int taskType = myList.get(i).getType();
			if(taskType == DeadlineType) {
				DeadlineTask tempTask = (DeadlineTask) myList.get(i);
				if(tempTask.getDate().equals(date)) {
					resultList.add(myList.get(i));
				}
			} else if (taskType == DurationType) {
				DurationTask tempTask = (DurationTask) myList.get(i);
				if(tempTask.getStartDate().equals(date)) {
					resultList.add(myList.get(i));
				}
			} 		
		}		
		return resultList;
	}
	
	public ArrayList<Tasks> searchBeforeDate(ArrayList<Tasks> myList, String date) throws ParseException {
		
		ArrayList<Tasks> resultList = new ArrayList<Tasks>();
		
		Date targetDate = stringToDate(date, 1);

		for(int i=0; i<myList.size(); i++) {
			
			int taskType = myList.get(i).getType();
			
			if(taskType == DeadlineType) {
				Date myDate = stringToDate(((DeadlineTask) myList.get(i)).getDate(),0);
				if(myDate.before(targetDate)) {
					resultList.add(myList.get(i));
				}
			} else if (taskType == DurationType) {
				Date myDate = stringToDate(((DurationTask) myList.get(i)).getStartDate(),0);
				if(myDate.before(targetDate)) {
					resultList.add(myList.get(i));
				}
			} 		
		}		
		return resultList;
	}
	
	public ArrayList<Tasks> searchOverDue(ArrayList<Tasks> myList) throws ParseException {
		
		ArrayList<Tasks> resultList = new ArrayList<Tasks>();
		
		Calendar today = Calendar.getInstance();
		Date now = today.getTime();
		
		for(int i=0; i<myList.size(); i++) {			
			int taskType = myList.get(i).getType();
			if(taskType == DeadlineType) {
				Date myDate = stringToDate(((DeadlineTask) myList.get(i)).getDate(),0);
				if(myDate.before(now)) {
					resultList.add(myList.get(i));
				}
			} else if (taskType == DurationType) {
				Date myDate = stringToDate(((DurationTask) myList.get(i)).getStartDate(),0);
				if(myDate.before(now)) {
					resultList.add(myList.get(i));
				}
			} 		
		}		
		return resultList;
	}
	
	public ArrayList<Tasks> searchBetweenDates(ArrayList<Tasks> myList, String date1, String date2) throws ParseException {
		
		ArrayList<Tasks> resultList = new ArrayList<Tasks>();
		ArrayList<Tasks> beforeDateB = new ArrayList<Tasks>();
		ArrayList<Tasks> afterDateA = new ArrayList<Tasks>();
		
		Date dateA = stringToDate(date1, -1);
		Date dateB = stringToDate(date2, 1);
		
		for(int i=0; i<myList.size(); i++) {
			
			int taskType = myList.get(i).getType();
			
			if(taskType == DeadlineType) {
				Date myDate = stringToDate(((DeadlineTask) myList.get(i)).getDate(),0);
				if(myDate.before(dateB)) {
					beforeDateB.add(myList.get(i));
				}
				if(myDate.after(dateA)) {
					afterDateA.add(myList.get(i));
				}
			} else if (taskType == DurationType) {
				Date myDate = stringToDate(((DurationTask) myList.get(i)).getStartDate(),0);
				if(myDate.before(dateB)) {
					beforeDateB.add(myList.get(i));
				}
				if(myDate.after(dateA)) {
					afterDateA.add(myList.get(i));
				}
			} 		
		}
		resultList = filterCommon(afterDateA, beforeDateB);
		
		return resultList;
	}
	

	private ArrayList<Tasks> searchType(ArrayList<Tasks> myList, int searchType) {
				
		ArrayList<Tasks> resultList = new ArrayList<Tasks>();
		
		for(int i=0; i<myList.size(); i++) {
			if(myList.get(i).getType() == searchType) {
				resultList.add(myList.get(i));
			}
		}		
		return resultList;
	}
	
	private Date stringToDate(String date, int offset) throws ParseException {

		DateFormat format = new SimpleDateFormat("ddMMyy", Locale.ENGLISH);		
		Calendar cal = Calendar.getInstance();
		
		cal.setTime(format.parse(date));
		cal.add( Calendar.DATE, offset );	
		
		Date returnDate = cal.getTime();
		return returnDate;
	}
	
	private ArrayList<Tasks> filterCommon(ArrayList<Tasks> listA, ArrayList<Tasks> listB) {
		listA.retainAll(listB);
		return listA;
	}
	
}
		
```
###### Time4WorkStorage\FloatingTask.java
``` java

public class FloatingTask extends Tasks{
	
	private static final int FloatingType = TaskType.FloatingType.getTaskType();
	
	public FloatingTask(int taskID, String desc) {
		super.setTaskID(taskID);
		super.setDescription(desc);
		super.setType(FloatingType);
	}
	
	public FloatingTask(String desc) {
		super.setDescription(desc);
		super.setType(FloatingType);
	}

}
```
###### Time4WorkStorage\Levenshtein.java
``` java
        if(costs[search.length()] > limit) {
        	return -1;
        } else {
        	return costs[search.length()];        	
        }
    }
}
```
###### Time4WorkStorage\Storage.java
``` java

public class Storage {
	
	//as constructor may try exception, create object when getInstance is called
	private static Storage theStorage = null; 
	private StorageLogic myLogic = new StorageLogic();
	private CustomPathLogic myPath = new CustomPathLogic();
	private static final String defFile = "myTasks.txt";
	
	private static final String BACKSLASH = "\\";
	private static final String FORWARDSLASH = "/";

	//use storage default path, <local directory>/myTasks.txt unless there's a previous saved path
	private Storage() throws IOException {
		
		String customPath = "";
		if(myPath.savedPathExists()) {
			customPath = myPath.readCustomPath();
			myLogic.createCustomFile(customPath, false);
		} else {
			myLogic.createDefaultFile();
		}
	}
	
	//custom path, path has to have escape characters
	//eg. C:\\user\\Desktop\\myTasks.txt
	public void setCustomPath(String path) throws IOException {
		
		String customPath = "";
		if(myPath.savedPathExists()) {
			customPath = myPath.readCustomPath();
		}
		
		File tempFile = new File(path);
		path = tempFile.getAbsolutePath();
		
		String tempPath = tempFile.toString();
		String parentPath = "";
		if(tempFile.getParentFile() != null) {
			parentPath = tempFile.getParentFile().toString();
		}
		String lastArgs = tempPath.substring(parentPath.length(), tempPath.length());
		
		if(!lastArgs.contains(".")) {
			String lastChar = path.substring(path.length() - 1);
			if(lastChar.equals(BACKSLASH) || lastChar.equals(FORWARDSLASH)) {
				path = path + defFile;
			}
			else {
				path = path + BACKSLASH + defFile;
			}
		}
		
		String newPath = path.replace(BACKSLASH, BACKSLASH+BACKSLASH);
		String pathChanged = "";
		
		if(!newPath.equalsIgnoreCase(customPath)) {
			pathChanged = myLogic.createCustomFile(path, true);	
			myPath.writeCustomPath(path);
		}
		
		if(!pathChanged.equals(customPath) && !pathChanged.equals("")){
			customPath = pathChanged;
			myPath.writeCustomPath(customPath);
		}
	}
	
	//read from file, deserialize and returns all tasks
	public ArrayList<Tasks> readFile() throws IOException {		
		try {
			return myLogic.getAllTasks();
		} catch (IOException e) {
			throw e;
		}		
	}

	//adds new task at the end of the list, returns back the new task if successful
	public Tasks appendTask(Tasks newTask) throws IOException {		
		try {
			return myLogic.addNewTask(newTask);
		} catch (IOException e) {
			throw e;
		}
	}	
	
	//deletes the input taskID, returns the deleted task, returns null if no matching taskID
	public ArrayList<Tasks> deleteTask(ArrayList<Integer> taskID) throws IOException, InterruptedException{		
		try {
			return myLogic.delete(taskID);
		} catch (IOException | InterruptedException e) {
			throw e;
		}		
	}
	
	//replaces specified taskID with updated Tasks and returns "old" updated task
	public Tasks UpdateTask(int taskID, Tasks updatedTask) throws Exception{
		
		ArrayList<Tasks> oldTask = null;
		ArrayList<Integer> myID = new ArrayList<Integer>();
		myID.add(taskID);
		
		try {
			oldTask = myLogic.delete(myID);
			myLogic.addNewTask(updatedTask);
			
		} catch (IOException | InterruptedException e) {
			throw e;
		}
		
		if(oldTask.size() == 0) {
			return null;
		} else {				
			return oldTask.get(0);
		}
	}
	
	//sets tasks as complete and returns the tasks
	public ArrayList<Tasks> SetCompleted(ArrayList<Integer> taskID) throws Exception{		
		try {
			return myLogic.setCompleted(taskID, true);
		} catch (IOException | InterruptedException e) {
			throw e;
		}		
	}
	
	//sets tasks as incomplete and returns the tasks
	public ArrayList<Tasks> SetIncompleted(ArrayList<Integer> taskID) throws Exception{		
		try {
			return myLogic.setCompleted(taskID, false);
		} catch (IOException | InterruptedException e) {
			throw e;
		}		
	}
	
	//clear the file of contents, does not delete file
	public ArrayList<Tasks> ClearAll() throws Exception{		
		try {
			return myLogic.clear();
		} catch (IOException | InterruptedException e) {
			throw e;
		}		
	}
	
	public static Storage getInstance() throws IOException {
		
		if(theStorage == null) {
			try {
				theStorage = new Storage();
			} catch (IOException e) {
				throw e;
			}
		}
		return theStorage;
	}
	
	public void deleteCustomPathFile() throws IOException {
		try {
			myPath.deleteCustomPathFile();
		} catch (IOException e) {
			throw e;
		}
	}
	
}
```
###### Time4WorkStorage\StorageLogic.java
``` java

public class StorageLogic {
			
	private static final int DeadlineType = TaskType.DeadlineType.getTaskType();
	private static final int DurationType = TaskType.DurationType.getTaskType();
	private static final int FloatingType = TaskType.FloatingType.getTaskType();
	
	private static final String MSG_FILECREATION_FAILED = "File already exists or directory not made";
	private static final String MSG_DIRCREATION_FAILED = "Unable to create directories";
	private static final String MSG_WRITEROPEN_FAILED = "Unable to create writer for file";
	private static final String MSG_READEROPEN_FAILED = "Unable to create reader for file";
	private static final String MSG_WRITERCLOSE_FAILED = "Unable to close writer";
	private static final String MSG_READERCLOSE_FAILED = "Unable to close reader";
	private static final String MSG_FILEDELETION_FAILED = "Unable to delete file";
	
	private static final String defPath = "myTasks.txt";
	private static final String TYPE_SPLITTER = "\"type\":";
	private static final String REG_REPLACE_SPACES_OUTSIDE_QUOTES = "\\s+(?=((\\\\[\\\\\"]|[^\\\\\"])*\"(\\\\[\\\\\"]|[^\\\\\"])*\")*(\\\\[\\\\\"]|[^\\\\\"])*$)";
	
	private File myFile;
	private FileWriter fw;
	private FileReader fr; 
	private BufferedWriter bw;
	private BufferedReader br;
	
	private String currentPath = "";	
	Gson gson = new GsonBuilder().setPrettyPrinting().create();
	
	//creates file at default directory, <local directory>/myTasks.txt
	public void createDefaultFile() throws IOException {
		
		currentPath = defPath;
		try {
			createFile(currentPath);
		} catch (IOException e) {
			throw e;
		}
	}	
	
	//custom path, path has to have escape characters for backslash
	//eg. C:\\user\\Desktop\\myTasks.txt
	//returns if a default file name is appended due to path not containing filename
	public String createCustomFile(String path, boolean transfer) throws IOException {
		
		String oldPath = currentPath;
		ArrayList<Tasks> tempList = new ArrayList<Tasks>();
		
		if(transfer) {
			tempList = getAllTasks();
			try {
				deleteDataFile();
			} catch (IOException e) {
				throw e;
			}
		}
		
		currentPath = path;		
		try {
			createFile(currentPath);
		} catch (IOException e) {
			currentPath = oldPath;
			return currentPath;
			//throw e;
		}
		
		if(transfer) {
			for(int i=0; i<tempList.size(); i++) {
				addNewTask(tempList.get(i));
			}
		}
		
		return currentPath;	
	}
	
	//if file doesn't exist, creates file and returns null
	//if file exists, read and return contents
	private ArrayList<Tasks> createFile(String currentPath) throws IOException {
		
		ArrayList<Tasks> myTaskList = new ArrayList<Tasks>();		
		myFile = new File(currentPath);
		
		try {
			CreateDirectories(myFile);
		}
		catch (IOException e) {
			throw e;
		}
		
		if(myFile.exists() && myFile.isFile()) {
			myTaskList = getAllTasks();
		} else {			
			try {
				myFile.createNewFile();
			} catch (IOException e) {
				throw new IOException(MSG_FILECREATION_FAILED);
			}
		}
		
		return myTaskList;
	}
	
	//checks if file contains path or just fileName.
	//Creates whole path if it's a path. Returns true on success file+directory creation
	private void CreateDirectories(File theFile) throws IOException {
		
		File parentFile = theFile.getParentFile();		
		
		if(parentFile != null) {
			if(!parentFile.mkdirs()) {
				if(!parentFile.exists()) {
					throw new IOException(MSG_DIRCREATION_FAILED);
				}
			}
		}
	}
	
	//reads and return all tasks in file
	public ArrayList<Tasks> getAllTasks() throws IOException {
		
		if(!myFile.exists()) {
			try {
				createFile(currentPath);
			} catch (IOException e) {
				throw e;
			}
		}
		
		try {
			openWriterReader();
		} catch (IOException e) {
			throw e;
		}
				
		ArrayList<Tasks> myTaskList = new ArrayList<Tasks>();
		String tempLine = "", fullLine = "";
		Tasks tempTask;
		
		//read contents of file		
		try {
			while ((tempLine = br.readLine()) != null) {
				fullLine += tempLine.replaceAll(REG_REPLACE_SPACES_OUTSIDE_QUOTES, "");
				
				if(tempLine.trim().equals("}")) {					
					fullLine = fullLine.replaceAll(REG_REPLACE_SPACES_OUTSIDE_QUOTES, "");
					int type = getTypeFromGsonString(fullLine);
					
					if (type == DeadlineType) {
						tempTask = gson.fromJson(fullLine, DeadlineTask.class);
					} else if (type == DurationType) {
						tempTask = gson.fromJson(fullLine, DurationTask.class);
					} else if (type == FloatingType) {
						tempTask = gson.fromJson(fullLine, FloatingTask.class);
					} else {
						tempTask = null;
					}
					
					if(tempTask != null ) {
						myTaskList.add(tempTask);
					}
					fullLine = "";
				}
			}
		} catch (JsonSyntaxException e) {
			throw e;
		} catch (IOException e) {
			throw e;
		}
		
		try {
			closeWriterReader();
		} catch (IOException e) {
			throw e;
		}
		   
		return myTaskList;
	}

	//retrieve type number from Gson string
	private int getTypeFromGsonString(String gsonString) {
		
		int type = 0;
		
		int startIndex = gsonString.indexOf(TYPE_SPLITTER)+TYPE_SPLITTER.length();
		type = Integer.parseInt( gsonString.substring(startIndex, startIndex+1));
		
		return type;
	}
	
	
	//adds new task at the end of file, generates taskID if not present
	public Tasks addNewTask(Tasks newTask) throws IOException {
		
		if(!myFile.exists()) {
			try {
				createFile(currentPath);
			} catch (IOException e) {
				throw e;
			}
		}
		
		try {
			openWriterReader();
		} catch (IOException e) {
			throw e;
		}
				
		//if task has no taskID, generate one!
		if(newTask.getTaskID() == 0) {
			try {
				newTask.setTaskID(GenerateTaskID());
			} catch (IOException e) {
				throw e;
			}
		}
		
		try {
			closeWriterReader();
		} catch (IOException e) {
			throw e;
		}
		
		String tempLine = gson.toJson(newTask);
		
		try {
			openWriterReader();
			bw.write(tempLine);
			bw.newLine();
			closeWriterReader();
		} catch (IOException e) {
			throw e;
		}
		
		return newTask;
	}
	
	//generate a valid taskID for requests
	private int GenerateTaskID() throws IOException {
		
		int largestID = 0;
		ArrayList<Tasks> myTaskList = new ArrayList<Tasks>();
		
		if(!myFile.exists()) {
			try {
				createFile(currentPath);
			} catch (IOException e) {
				throw e;
			}
		}
		
		try {
			openWriterReader();
			myTaskList = getAllTasks();
		} catch (IOException e) {
			throw e;
		}
		
		for(int i=0; i<myTaskList.size(); i++) {
			if(myTaskList.get(i).getTaskID() > largestID) {
				largestID = myTaskList.get(i).getTaskID();
			}
		}
		
		try {
			closeWriterReader();
		} catch (IOException e) {
			throw e;
		}
		
		return largestID +1;
	}
	

	private void openWriterReader() throws IOException, FileNotFoundException{

		try {
			fw = new FileWriter(myFile.getAbsoluteFile(),true);
			bw = new BufferedWriter(fw);
		} catch (IOException e) {
			throw new IOException(MSG_WRITEROPEN_FAILED);
		}
		try {
			fr = new FileReader(myFile.getAbsoluteFile());
			br = new BufferedReader(fr);
		} catch (FileNotFoundException e) {
			throw new FileNotFoundException(MSG_READEROPEN_FAILED);
		}
	}
	

	private void closeWriterReader() throws IOException {

			try {
				bw.close();
			} catch (IOException e) {
				throw new IOException(MSG_WRITERCLOSE_FAILED);
			}
			try {
				br.close();
			} catch (IOException e) {
				throw new IOException(MSG_READERCLOSE_FAILED);
			}
	}

	//searches and deletes the indicated taskIDs, if not found, returns null, if deleted returns deleted tasks 
	public ArrayList<Tasks> delete(ArrayList<Integer> taskID) throws IOException, InterruptedException {
		
		ArrayList<Tasks> deletedTask = new ArrayList<Tasks>();
		ArrayList<Tasks> myTaskList = new ArrayList<Tasks>();
		
		if(!myFile.exists()) {
			try {
				createFile(currentPath);
			} catch (IOException e) {
				throw e;
			}
		}
		
		try {
			openWriterReader();
			myTaskList = getAllTasks();
		} catch (IOException e) {
			throw e;
		}
		
		boolean needDelete = false;

		for(int i=0; i<myTaskList.size(); i++) {
			for(int j=0; j<taskID.size(); j++) {
				if(myTaskList.get(i).getTaskID() == taskID.get(j)) {
					needDelete = true;
					deletedTask.add(myTaskList.get(i));
					myTaskList.remove(i);
					i--;
					break;
				}
			}
		}
		
		//taskID to be deleted is found
		if(needDelete) {
			
			try {
				closeWriterReader();
				deleteDataFile();
				createFile(currentPath);
				openWriterReader();
			} catch (IOException e) {
				throw e;
			}
						
			for(int i=0; i<myTaskList.size(); i++) {
				String tempLine = gson.toJson(myTaskList.get(i)); 
			
				try {
					bw.write(tempLine);
					bw.newLine();
				}  catch (IOException e) {
					throw e;
				}
			}
		}
		
		try {
			closeWriterReader();
		} catch (IOException e) {
			throw e;
		}
			
		return deletedTask;		
	}

	//sets tasks as completed, returns the target tasks
	public ArrayList<Tasks> setCompleted(ArrayList<Integer> taskID, boolean status) throws IOException, InterruptedException {
		
		ArrayList<Tasks> editedTask = new ArrayList<Tasks>();
		ArrayList<Tasks> myTaskList = new ArrayList<Tasks>();
		
		if(!myFile.exists()) {
			try {
				createFile(currentPath);
			} catch (IOException e) {
				throw e;
			}
		}
		
		boolean needUpdate = false;
		
		try {
			openWriterReader();
			myTaskList = getAllTasks();
		} catch (IOException e) {
			throw e;
		}
		
		for(int i=0; i<myTaskList.size(); i++) {
			for(int j=0; j<taskID.size(); j++) {
				if(myTaskList.get(i).getTaskID() == taskID.get(j)) {
					if(myTaskList.get(i).isCompleted() != status) {
						needUpdate = true;
						editedTask.add(myTaskList.get(i));	
						myTaskList.get(i).setCompleted(status);	
					}
				}
			}
		}
		
		//taskID to be deleted is found
		if(needUpdate) {
			
			try {
				closeWriterReader();
				deleteDataFile();
				createFile(currentPath);
				openWriterReader();
			} catch (IOException e) {
				throw e;
			}
			
			for(int i=0; i<myTaskList.size(); i++) {
				String tempLine = gson.toJson(myTaskList.get(i)); 
			
				try {
					bw.write(tempLine);
					bw.newLine();
				}  catch (IOException e) {
					throw e;
				}
			}
		}
		
		try {
			closeWriterReader();
		} catch (IOException e) {
			throw e;
		}
			
		return editedTask;
		
	}

	//deletes the file and recreates it, returning all the deleted tasks
	public ArrayList<Tasks> clear() throws IOException, InterruptedException {
		
		ArrayList<Tasks> myTaskList = new ArrayList<Tasks>();
		

		if(!myFile.exists()) {
			try {
				createFile(currentPath);
			} catch (IOException e) {
				throw e;
			}
		}
		
		try {
			openWriterReader();
			myTaskList = getAllTasks();
			closeWriterReader();
			deleteDataFile();
			createFile(currentPath);
		} catch (IOException e) {
			throw e;
		}
					
		return myTaskList;
		
	}
	
	public void deleteDataFile() throws IOException {
		
		try {
			closeWriterReader();
			fr.close();
			br.close();
		} catch (IOException e) {
			throw e;
		}
		
		System.gc();
		
		try {
			Thread.sleep(200);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		if (!myFile.delete()) {
			throw new IOException(MSG_FILEDELETION_FAILED);
	    } 
	}
	
	public String getCurrentPath() {
		return currentPath;
	}

	public void setCurrentPath(String currentPath) {
		this.currentPath = currentPath;
	}

}
```
###### Time4WorkStorage\Tasks.java
``` java

public abstract class Tasks {
	private int taskID;
	private String description = "";		 
	private boolean completed = false;
	private int type = 0;
	
	public enum TaskType {
		DeadlineType(1), DurationType(2), FloatingType(3);
		private int myType = 0;
		
		private TaskType(int thisType) {
			this.myType = thisType;
		}
		
		public int getTaskType() {
	        return myType;
	    }
	}
	
	public int getTaskID() {
		return taskID;
	}

	public void setTaskID(int taskID) {
		this.taskID = taskID;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public int getType() {
		return type;
	}

	public void setType(int type) {
		this.type = type;
	}

	public boolean isCompleted() {
		return completed;
	}

	public void setCompleted(boolean completed) {
		this.completed = completed;
	}
	
	
	
}
```
